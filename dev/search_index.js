var documenterSearchIndex = {"docs":
[{"location":"custorm/#Customization","page":"Customization","title":"Customization","text":"","category":"section"},{"location":"custorm/#Nilpotent-Matrix","page":"Customization","title":"Nilpotent Matrix","text":"","category":"section"},{"location":"custorm/#Default-Nilpotent-Matrix","page":"Customization","title":"Default Nilpotent Matrix","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"Nilp(nbOne::Ti, size::Ti) where {Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.Nilp-Union{Tuple{Ti}, Tuple{Ti, Ti}} where Ti<:Integer","page":"Customization","title":"SMG2S.Nilp","text":"Nilp(nbOne::Ti, size::Ti) where {Ti<:Integer}\n\nCreate a nilpotent matrix object with parameters nbOne and size. size refers to the size of nilpotent matrix to be generated, and nbOne refers to the number of continuous 1 on the non-zero diagonal of generated nilptent matrix.\n\nThis is the default type of nilptent matrix used by SMG2S, in which the non-zero diagonal is selected as the one of offset 1. This diagonal starts with nbOne number of 1, then a 0, then nbOne number of 1, ... until to the end.\n\nExamples\n\njulia> SMG2S.Nilp(2,8)\nNilpotent{Int64}(2, 8, 3,\n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ )\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Construction-from-User-provided-vector","page":"Customization","title":"Construction from User-provided vector","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"Nilp(vector::AbstractVector, size::Ti) where {Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.Nilp-Union{Tuple{Ti}, Tuple{AbstractVector{T} where T, Ti}} where Ti<:Integer","page":"Customization","title":"SMG2S.Nilp","text":"Nilp(vector::AbstractVector, size::Ti) where {Ti<:Integer}\n\nCreate a nilpotent matrix whose dimension is size from user-provided vector. The non-zero diagonal of nilpotent matrix is fixed as the one with offset 1. Therefore, the size of given vector should at least be size-1.\n\nExamples\n\njulia> vec=[1; 1; 0; 1; 1; 1; 0]\n7-element Vector{Int64}:\n 1\n 1\n 0\n 1\n 1\n 1\n 0\n\njulia> SMG2S.Nilp(vec, 8)\nNilpotent{Int64}(3, 8, 4,\n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ )\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Construction-from-User-provided-Sparse-Matrix","page":"Customization","title":"Construction from User-provided Sparse Matrix","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"Nilp(matrix::SparseMatrixCSC{Tv, Ti} ,size::Ti; maxdegree::Ti=80) where{Tv <: Real, Ti <: Integer}","category":"page"},{"location":"custorm/#SMG2S.Nilp-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, Ti}} where {Tv<:Real, Ti<:Integer}","page":"Customization","title":"SMG2S.Nilp","text":"Nilp(matrix::SparseMatrixCSC{Tv, Ti} ,size::Ti; maxdegree::Ti=80) where{Tv <: Real, Ti <: Integer}\n\nCreate a nilpotent matrix whose dimension is size from user-provided sparse matrix matrix. This matrix should be nilpotent, and its nilpotency should not be larger than 80. Before generation, SMG2S.jl will check if the user-provided matrix is nilpotent matrix with nilpotency no larger than 80. If it doesn't satisfy any of the two, an error message will appear.\n\nExamples\n\njulia> nilpMatrix = sparse([0. 1 1 0; 0 0 1 1 ; 0 0 0 1 ; 0 0 0 0])\n4×4 SparseMatrixCSC{Float64, Int64} with 5 stored entries:\n  ⋅   1.0  1.0   ⋅\n  ⋅    ⋅   1.0  1.0\n  ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅\n\njulia> SMG2S.Nilp(nilpMatrix,4)\n┌ Info: the degree of given nilpotent matrix is:\n└   degree = 4\nNilpotent{Int64}(1, 4, 4,\n  ⋅   1.0  1.0   ⋅\n  ⋅    ⋅   1.0  1.0\n  ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅ )\n\nExamples\n\njulia> nilpMatrix = sparse([1. 1 1 0; 0 0 1 1 ; 0 0 0 1 ; 0 0 0 0])\n4×4 SparseMatrixCSC{Float64, Int64} with 6 stored entries:\n 1.0  1.0  1.0   ⋅\n  ⋅    ⋅   1.0  1.0\n  ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅\n\njulia> SMG2S.Nilp(nilpMatrix,4)\nERROR: the given nilpotent matrix is invalid\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Construction-from-User-provided-vector-with-specific-diagonal-offset","page":"Customization","title":"Construction from User-provided vector with specific diagonal offset","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"Nilp(vec::AbstractVector, diag::Ti, size::Ti) where{Ti <: Integer}","category":"page"},{"location":"custorm/#SMG2S.Nilp-Union{Tuple{Ti}, Tuple{AbstractVector{T} where T, Ti, Ti}} where Ti<:Integer","page":"Customization","title":"SMG2S.Nilp","text":"Nilp(vec::AbstractVector, diag::Ti, size::Ti) where{Ti <: Integer}\n\nCreate a nilpotent matrix whose dimension is size from user-provided vector. The non-zero diagonal of nilpotent matrix is set as the one with offset diag. Therefore, the size of given vector should at least be size-diag.\n\nExamples\n\njulia> vec=[1; 1; 0; 1; 1; 1; 0]\n7-element Vector{Int64}:\n 1\n 1\n 0\n 1\n 1\n 1\n 0\n\njulia> SMG2S.Nilp(vec, 3, 8)\n┌ Info: the degree of given nilpotent matrix is:\n└   degree = 3\nNilpotent{Int64}(1, 8, 3,\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅)\n\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Construction-from-specific-diagonal-offset","page":"Customization","title":"Construction from specific diagonal offset","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"Nilp(nbOne::Ti, diag::Ti, size::Ti) where{Ti <: Integer}","category":"page"},{"location":"custorm/#SMG2S.Nilp-Union{Tuple{Ti}, Tuple{Ti, Ti, Ti}} where Ti<:Integer","page":"Customization","title":"SMG2S.Nilp","text":"Nilp(nbOne::Ti, diag::Ti, size::Ti) where{Ti <: Integer}\n\nCreate a nilpotent matrix object with parameters nbOne, diag and size. size refers to the size of nilpotent matrix to be generated, and nbOne refers to the maximum number of continuous 1 on the non-zero diagonal of generated nilptent matrix. The offset of non-zero diagonal is determined by the parameter diag.\n\nThe non-zero diagonal is generated as:\n\nrandomly generating an interger number in the interval [1, nbOne]\nthis number determines the number of continous 1 for this time of sampling\nthen generating another within the same interval, which determines the number of continuous 0\nthen re-samling for a new sequence of continuous 1\n...\n\nExamples\n\njulia> SMG2S.Nilp(4, 3, 15)\n┌ Info: the degree of given nilpotent matrix is:\n└   degree = 3\nNilpotent{Int64}(1, 15, 3,\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅)\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Initialization-of-Matrix","page":"Customization","title":"Initialization of Matrix","text":"","category":"section"},{"location":"custorm/#Non-Hermtian-Case","page":"Customization","title":"Non-Hermtian Case","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"initMat!(matrix::SparseMatrixCSC{Tv, Ti}, diag_l::Ti, diag_u::Ti, size::Ti; scale::Real = 1.0, shift::Real = 0.0, sparsity::Real = 0.9) where {Tv<:Complex, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.initMat!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, Ti, Ti, Ti}} where {Tv<:Complex, Ti<:Integer}","page":"Customization","title":"SMG2S.initMat!","text":"initMat!(matrix::SparseMatrixCSC{Tv, Ti}, diag_l::Ti, diag_u::Ti, size::Ti; scale::Real = 1.0, shift::Real = 0.0, sparsity::Real = 0.9) where {Tv<:Complex, Ti<:Integer}\n\nInitialization of matrix to be generated. This function is for non-Hermitian case, in which the entries of matrix are complex scalars.\n\nIn this function, the parameters diag_l and diag_u determine the range ([diag_l, diag_u]) of lower triangular part to be filled. The two parameters should also be negatif, which refer to the offfsets of diagonals in the lower triangular part. The parameter size defines the size of matrix to be generated.\n\nThe non-zero elements of the initialized matrices are randomly generated in the interval (0,1). Two optionals parameters shift and scale allow shifting and scaling this interval.\n\nAnother optional parameter sparsity is more important. It determines the possility of the elements within the band of diagonal determined by diag_l and diag_u to be non-zeros. In other words, the initalized matrix would be more sparse with a smaller number of sparisty parameter.\n\nExamples\n\njulia> Am=spzeros(ComplexF64, 50, 50);\njulia> initMat!(Am, -20, -10, 50)\njulia> Am\n50×50 SparseMatrixCSC{ComplexF64, Int64} with 335 stored entries:\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣟⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣿⣿⣢⣵⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠙⢟⣾⣿⣽⢲⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠙⢽⣿⣛⣿⣵⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠙⠽⣻⡾⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠙⢟⣻⢿⢻⣗⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣽⣯⣻⣳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣛⢿⡾⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢯⡽⣯⣜⣷⢄⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠚⠋⠛⠚⠓⠀⠀⠀⠀⠀\n\n\nExamples\n\njulia> Am=spzeros(ComplexF64, 50, 50);\njulia> initMat!(Am, -20, -10, 50, sparsity=0.1)\njulia> Am\n50×50 SparseMatrixCSC{ComplexF64, Int64} with 36 stored entries:\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠠⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠉⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⢂⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠂⠈⠀⠤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⢀⢀⠅⠂⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠠⠈⠰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠈⠀⠡⢀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⢄⡆⢀⠀⠀⠀⠀⠀⠀\n\n\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Non-Symmetric-Case","page":"Customization","title":"Non-Symmetric Case","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"initMat!(matrix::SparseMatrixCSC{Tv, Ti}, diag_l::Ti, diag_u::Ti, size::Ti; scale::Real = 1.0, shift::Real = 0.0, sparsity::Real = 0.9) where {Tv<:Real, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.initMat!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv, Ti}, Ti, Ti, Ti}} where {Tv<:Real, Ti<:Integer}","page":"Customization","title":"SMG2S.initMat!","text":"initMat!(matrix::SparseMatrixCSC{Tv, Ti}, diag_l::Ti, diag_u::Ti, size::Ti; scale::Real = 1.0, shift::Real = 0.0, sparsity::Real = 0.9) where {Tv<:Real, Ti<:Integer}\n\nInitialization of matrix to be generated. This function is for non-Symmetric case, in which the entries of matrix are real scalars.\n\nThe usage of this function is quite similar as the one for non-Hermitian case, the only difference is that the entries of matrices are real scalars.\n\nExamples\n\njulia> Am=spzeros(Float64, 50, 50);\njulia> initMat!(Am, -20, -10, 50, sparsity=0.5)\njulia> Am\n50×50 SparseMatrixCSC{Float64, Int64} with 178 stored entries:\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠌⡱⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠍⠫⢠⡀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠈⠏⣌⠺⣑⠰⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠙⣣⢑⡿⢡⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠅⣊⡼⠖⠷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠉⢀⣫⠇⢛⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠑⠟⡕⣭⠉⣱⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢐⡚⢘⠔⣡⢄⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠪⡌⡆⣜⣆⢀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠒⠉⠂⠘⠁⠀⠀⠀⠀⠀\n\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Set-Spectrum","page":"Customization","title":"Set Spectrum","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"Spectrum!(spec::AbstractVector{Tv}, f::Function, size::Ti) where {Tv<:Complex, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.Spectrum!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, Function, Ti}} where {Tv<:Complex, Ti<:Integer}","page":"Customization","title":"SMG2S.Spectrum!","text":"Spectrum!(spec::AbstractVector{Tv}, f::Function, size::Ti) where {Tv<:Complex, Ti<:Integer}\n\nSet the spectrum from user provided function.\n\nExamples\n\njulia> function f(idx::Integer, size = 10)\n           return 10 * cos(((idx-1) / 2) * 2 * π / size) + sin(((idx-1) / 2) * 2 * π / size) * im\n       end\nf (generic function with 2 methods)\n\njulia> vec=zeros(ComplexF64, 10);\n\njulia> Spectrum!(vec, f, 10);\n\njulia> vec\n10-element Vector{ComplexF64}:\n                  10.0 + 0.0im\n     9.510565162951535 + 0.3090169943749474im\n     8.090169943749475 + 0.5877852522924731im\n     5.877852522924732 + 0.8090169943749475im\n    3.0901699437494745 + 0.9510565162951535im\n 6.123233995736766e-16 + 1.0im\n   -3.0901699437494736 + 0.9510565162951536im\n     -5.87785252292473 + 0.8090169943749475im\n    -8.090169943749473 + 0.5877852522924732im\n    -9.510565162951535 + 0.3090169943749475im\n\n\n\n\n\n\n","category":"method"},{"location":"custorm/","page":"Customization","title":"Customization","text":"Spectrum!(spec::AbstractVector{Tv}, vec::AbstractVector{Tv}, size::Ti) where {Tv<:Complex, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.Spectrum!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, AbstractVector{Tv}, Ti}} where {Tv<:Complex, Ti<:Integer}","page":"Customization","title":"SMG2S.Spectrum!","text":"Spectrum!(spec::AbstractVector{Tv}, vec::AbstractVector{Tv}, size::Ti) where {Tv<:Complex, Ti<:Integer}\n\nSet the spectrum from user provided vector. In fact, this function only check if the size of given spectrum vector is large enough. And they copy the first size elements of vec into spec.\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Assembling-the-Customizations","page":"Customization","title":"Assembling the Customizations","text":"","category":"section"},{"location":"custorm/#Non-Hermitian-Case","page":"Customization","title":"Non-Hermitian Case","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"nonherm(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}) where {Tv<:Complex, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.nonherm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Ti, Ti, Ti, Ti, AbstractVector{Tv}}} where {Tv<:Complex, Ti<:Integer}","page":"Customization","title":"SMG2S.nonherm","text":"nonherm(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}) where {Tv<:Complex, Ti<:Integer}\n\nGenerate a non hermitian matrix with default nilpotent matrix and default initialization of matrix.\n\nExamples\n\njulia> spec=[1+im, 2, 4, 6, 7-2im, 4+3im, 7, 8, 9, 10.2-im]\n10-element Vector{ComplexF64}:\n  1.0 + 1.0im\n  2.0 + 0.0im\n  4.0 + 0.0im\n  6.0 + 0.0im\n  7.0 - 2.0im\n  4.0 + 3.0im\n  7.0 + 0.0im\n  8.0 + 0.0im\n  9.0 + 0.0im\n 10.2 - 1.0im\n\njulia> nonherm(3, 10, -8, -2, spec)\n10×10 SparseMatrixCSC{ComplexF64, Int64} with 66 stored entries:\n   1.04657+1.0im    -0.4959+0.5im  0.0833701+0.0833333im  0.00347223+0.00347222im            ⋅                ⋅               ⋅                     ⋅                ⋅           ⋅\n -0.231523+0.0im     1.9567+0.0im   -1.00012+0.0im        3.02285e-5+0.0im                   ⋅                ⋅               ⋅                     ⋅                ⋅           ⋅\n  0.207446+0.0im  -0.115496+0.0im    3.94688+0.0im          -1.00394+0.0im                   ⋅                ⋅               ⋅                     ⋅                ⋅           ⋅\n  0.766797+0.0im   0.949636+0.0im   0.347018+0.0im           6.04985+0.0im                   ⋅                ⋅               ⋅                     ⋅                ⋅           ⋅\n  0.413475+0.0im   0.847118+0.0im    1.11204+0.0im          0.240384+0.0im           7.05096-2.0im    1.50334-2.5im  0.500002-0.666667im  0.0277777-0.0381944im      ⋅           ⋅\n -0.114481+0.0im   0.314934+0.0im   0.463301+0.0im          0.257056+0.0im         -0.253119+0.0im     3.9802+3.0im  -1.49669+1.5im       -0.166576+0.25im           ⋅           ⋅\n  0.592639+0.0im   0.167683+0.0im  -0.318934+0.0im          0.847507+0.0im          0.225334+0.0im  -0.292356+0.0im    6.8867+0.0im       -0.507753+0.0im            ⋅           ⋅\n  0.112486+0.0im   0.332264+0.0im   0.799049+0.0im          0.349224+0.0im          0.842714+0.0im    1.37186+0.0im  0.545475+0.0im         8.08213+0.0im            ⋅           ⋅\n   0.96467+0.0im    1.36421+0.0im    1.13479+0.0im          0.769023+0.0im         -0.219469+0.0im  -0.196588+0.0im   0.26921+0.0im        0.154841+0.0im        9.0+0.0im  -0.6+0.5im\n           ⋅        0.12781+0.0im   0.438092+0.0im           1.12886+0.0im          0.438939+0.0im   0.466332+0.0im  0.160009+0.0im        0.022096+0.0im            ⋅      10.2-1.0im\n\n\n\n\n\n","category":"method"},{"location":"custorm/","page":"Customization","title":"Customization","text":"nonherm(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv, Ti}) where {Tv<:Complex, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.nonherm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Ti, Ti, Ti, Ti, AbstractVector{Tv}, SparseMatrixCSC{Tv, Ti}}} where {Tv<:Complex, Ti<:Integer}","page":"Customization","title":"SMG2S.nonherm","text":"nonherm(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv, Ti}) where {Tv<:Complex, Ti<:Integer}\n\nGenerate a non hermitian matrix with default nilpotent matrix and user-provided initialization of matrix.\n\nExamples\n\njulia> spec=[1+im, 2, 4, 6, 7-2im, 4+3im, 7, 8, 9, 10.2-im]\n10-element Vector{ComplexF64}:\n  1.0 + 1.0im\n  2.0 + 0.0im\n  4.0 + 0.0im\n  6.0 + 0.0im\n  7.0 - 2.0im\n  4.0 + 3.0im\n  7.0 + 0.0im\n  8.0 + 0.0im\n  9.0 + 0.0im\n 10.2 - 1.0im\n\njulia> Am = spzeros(ComplexF64, 10, 10);\njulia> initMat!(Am, -8, -2, 10; scale=0.1, sparsity=0.005)\njulia> nonherm(3, 10, -8, -2, spec, Am)\n10×10 SparseMatrixCSC{ComplexF64, Int64} with 22 stored entries:\n 1.0+1.0im  -0.5+0.5im  0.0833333+0.0833333im  0.00347222+0.00347222im      ⋅          ⋅           ⋅                     ⋅                ⋅           ⋅\n     ⋅       2.0+0.0im       -1.0+0.0im                   ⋅                 ⋅          ⋅           ⋅                     ⋅                ⋅           ⋅\n     ⋅           ⋅            4.0+0.0im              -1.0+0.0im             ⋅          ⋅           ⋅                     ⋅                ⋅           ⋅\n     ⋅           ⋅                ⋅                   6.0+0.0im             ⋅          ⋅           ⋅                     ⋅                ⋅           ⋅\n     ⋅           ⋅                ⋅                       ⋅             7.0-2.0im  1.5-2.5im   0.5-0.666667im  0.0277778-0.0381944im      ⋅           ⋅\n     ⋅           ⋅                ⋅                       ⋅                 ⋅      4.0+3.0im  -1.5+1.5im       -0.166667+0.25im           ⋅           ⋅\n     ⋅           ⋅                ⋅                       ⋅                 ⋅          ⋅       7.0+0.0im            -0.5+0.0im            ⋅           ⋅\n     ⋅           ⋅                ⋅                       ⋅                 ⋅          ⋅           ⋅                 8.0+0.0im            ⋅           ⋅\n     ⋅           ⋅                ⋅                       ⋅                 ⋅          ⋅           ⋅                     ⋅            9.0+0.0im  -0.6+0.5im\n     ⋅           ⋅                ⋅                       ⋅                 ⋅          ⋅           ⋅                     ⋅                ⋅      10.2-1.0im\n\n\n\n\n\n","category":"method"},{"location":"custorm/","page":"Customization","title":"Customization","text":"nonherm(size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv, Ti}, nilp::Nilpotent{Ti}) where {Tv<:Complex, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.nonherm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Ti, Ti, Ti, AbstractVector{Tv}, SparseMatrixCSC{Tv, Ti}, Nilpotent{Ti}}} where {Tv<:Complex, Ti<:Integer}","page":"Customization","title":"SMG2S.nonherm","text":"nonherm(size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv, Ti}, nilp::Nilpotent{Ti}) where {Tv<:Complex, Ti<:Integer}\n\nGenerate a non hermitian matrix with user-provided nilpotent matrix and initialization of matrix.\n\nExamples\n\njulia> spec=[1+im, 2, 4, 6, 7-2im, 4+3im, 7, 8, 9, 10.2-im]\n10-element Vector{ComplexF64}:\n  1.0 + 1.0im\n  2.0 + 0.0im\n  4.0 + 0.0im\n  6.0 + 0.0im\n  7.0 - 2.0im\n  4.0 + 3.0im\n  7.0 + 0.0im\n  8.0 + 0.0im\n  9.0 + 0.0im\n 10.2 - 1.0im\n\njulia> Am = spzeros(ComplexF64, 10, 10);\njulia> initMat!(Am, -8, -2, 10; scale=0.1, sparsity=0.005)\njulia> nilp=SMG2S.Nilp(4, 3, 10)\n┌ Info: the degree of given nilpotent matrix is:\n└   degree = 2\nNilpotent{Int64}(1, 10, 2,\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅)\n\njulia> nonherm(10, -8, -2, spec, Am, nilp)\n10×10 SparseMatrixCSC{ComplexF64, Int64} with 13 stored entries:\n 1.0+1.0im      ⋅          ⋅      -2.5+0.5im      ⋅          ⋅          ⋅           ⋅          ⋅           ⋅\n     ⋅      2.0+0.0im      ⋅           ⋅          ⋅          ⋅          ⋅           ⋅          ⋅           ⋅\n     ⋅          ⋅      4.0+0.0im       ⋅          ⋅          ⋅          ⋅           ⋅          ⋅           ⋅\n     ⋅          ⋅          ⋅       6.0+0.0im      ⋅          ⋅          ⋅           ⋅          ⋅           ⋅\n     ⋅          ⋅          ⋅           ⋅      7.0-2.0im      ⋅          ⋅      -0.5-1.0im      ⋅           ⋅\n     ⋅          ⋅          ⋅           ⋅          ⋅      4.0+3.0im      ⋅           ⋅          ⋅           ⋅\n     ⋅          ⋅          ⋅           ⋅          ⋅          ⋅      7.0+0.0im       ⋅          ⋅      -1.6+0.5im\n     ⋅          ⋅          ⋅           ⋅          ⋅          ⋅          ⋅       8.0+0.0im      ⋅           ⋅\n     ⋅          ⋅          ⋅           ⋅          ⋅          ⋅          ⋅           ⋅      9.0+0.0im       ⋅\n     ⋅          ⋅          ⋅           ⋅          ⋅          ⋅          ⋅           ⋅          ⋅      10.2-1.0im\n\n\n\n\n\n","category":"method"},{"location":"custorm/#Non-Symmetric-Matrix","page":"Customization","title":"Non-Symmetric Matrix","text":"","category":"section"},{"location":"custorm/","page":"Customization","title":"Customization","text":"nonsym(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}) where {Tv<:Complex, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.nonsym-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Ti, Ti, Ti, Ti, AbstractVector{Tv}}} where {Tv<:Complex, Ti<:Integer}","page":"Customization","title":"SMG2S.nonsym","text":"nonsym(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}) where {Tv<:Complex, Ti<:Integer}\n\nGenerate a non symmetric matrix with default nilpotent matrix and default initialization of matrix.\n\nThe usage of nonsym is the same as the one of nonherm, please refers to that part for more detais.\n\nPlease keep in mind the constraints of given spectrum vector and initialization of matrix, click here for more details.\n\n\n\n\n\n","category":"method"},{"location":"custorm/","page":"Customization","title":"Customization","text":"nonsym(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv2, Ti},) where {Tv<:Complex, Tv2<:Real, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.nonsym-Union{Tuple{Ti}, Tuple{Tv2}, Tuple{Tv}, Tuple{Ti, Ti, Ti, Ti, AbstractVector{Tv}, SparseMatrixCSC{Tv2, Ti}}} where {Tv<:Complex, Tv2<:Real, Ti<:Integer}","page":"Customization","title":"SMG2S.nonsym","text":"nonsym(nbOne::Ti, size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv2, Ti},) where {Tv<:Complex, Tv2<:Real, Ti<:Integer}\n\nGenerate a non symmetric matrix with default nilpotent matrix and user-provided initialization of matrix.\n\nThe usage of nonsym is the same as the one of nonherm, please refers to that part for more detais.\n\nPlease keep in mind the constraints of given spectrum vector and initialization of matrix, click here for more details.\n\n\n\n\n\n","category":"method"},{"location":"custorm/","page":"Customization","title":"Customization","text":"nonsym(size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv2, Ti}, nilp::Nilpotent{Ti}) where {Tv<:Complex, Tv2<:Real, Ti<:Integer}","category":"page"},{"location":"custorm/#SMG2S.nonsym-Union{Tuple{Ti}, Tuple{Tv2}, Tuple{Tv}, Tuple{Ti, Ti, Ti, AbstractVector{Tv}, SparseMatrixCSC{Tv2, Ti}, Nilpotent{Ti}}} where {Tv<:Complex, Tv2<:Real, Ti<:Integer}","page":"Customization","title":"SMG2S.nonsym","text":"nonsym(size::Ti, diag_l::Ti, diag_u::Ti, spectrum::AbstractVector{Tv}, Am::SparseMatrixCSC{Tv2, Ti}, nilp::Nilpotent{Ti}) where {Tv<:Complex, Tv2<:Real, Ti<:Integer}\n\nGenerate a non symmetric matrix with user-provided nilpotent matrix and initialization of matrix.\n\nThe usage of nonsym is the same as the one of nonherm, please refers to that part for more detais.\n\nPlease keep in mind the constraints of given spectrum vector and initialization of matrix, click here for more details.\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Matrix-generation-framework","page":"Getting Started","title":"Matrix generation framework","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's consider a collection of matrices M(t) in mathbbC^n times n, n in mathbbN^*. If M(t) verifies:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\nfracdM(t)dt = AM(t) - M(t)A \nM(t=0) = M_0 \nendaligned","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Then M(t) and M_0 are similar. M(t) has the same eigenvalues as M_0.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A simple proof is available in the the relevant paper.","category":"page"},{"location":"getting_started/#Matrix-Generation-Method","page":"Getting Started","title":"Matrix Generation Method","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The idea may seem simple, but many parameters need to be determined to achieve our objective.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Denote a linear operator of matrix M determined by matrix A as widetildeA_A = AM-MA, forall A in mathbbC^n times n, M in mathbbC^n times n, n in mathbbN^*. Here AM and MA are the matrix-matrix multiplication operation of matrices A and M. By solving the differential equation introduced in the previous section, we can firstly get the formula of M(t) with the exponential operator and then extend it by the Taylor series formula:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"beginaligned\nM(t) = e^widetildeA_A(M_0)t \nM(t) = sum_k=0^inftyfract^kk(widetildeA_A)^k (M_0) \nendaligned","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Through the loop M_i+1=M_i+frac1i(widetildeA_A)^i(M_0) iin(0+infty), a very simple initial matrix M_0 in mathbbC^n times n can be converted into a new sparse, non-trivial and non-Hermitian matrix M_+infty in mathbbC^n times n, which has the same spectra but different eigenvectors with M_0.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A good selection of matrix A can make widetilde(A_A)^i tend to 0 in limited steps. We select A as a nilpotent matrix, such that there exists an integer k which leads to A^i=0 for all i ge k. Such k is called the nilpotency of A.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The initial matrix M_0 is selected as a sparse low triangular matrices, whose eigenvalues are exactly the same as the given spectrum.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nFor generating non-Hermitian and non-Symmetric sparse matrices, the initializations of M₀ are different.","category":"page"},{"location":"getting_started/#Building-Blocks","page":"Getting Started","title":"Building Blocks","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"There are three important building blocks, which should be taken care of (in another words, customized) by the users.","category":"page"},{"location":"getting_started/#Spectrum-specified-by-Users","page":"Getting Started","title":"Spectrum specified by Users","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Constraints are posed for the spectrum provided by users to generate targeting matrices, especially for the non-symmetric case.","category":"page"},{"location":"getting_started/#Non-Hermitian-matrix","page":"Getting Started","title":"Non-Hermitian matrix","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For the Hermitian matrices, the spectrum can be specified as a n-element vector, whose entries (eigenvalues) can be any real or complex number, e.g.,","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"spectrum = 12+i3-3i45+i 6-21i 7 8 ","category":"page"},{"location":"getting_started/#Non-Symmetric-matrix","page":"Getting Started","title":"Non-Symmetric matrix","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For the non-Symmetric case, the spectrum should also be specified as a n-element vector with real and/or complex entries (eigenvalues). However, for the entries with complex number, they should appear as conjugate pairs. For example, if the first complex entry is a+bi, either its left or right neighboring entry should be its conjugate a-bi. This constraint is posed because of the fact that the eigenvalues of non-symmetric matrices with real values always come out as conjugate pairs, if they are complex. Voilà an example:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"spectrum = 1 2-i 2+i 3-2i 3+2i -5 4+9i 4-9i","category":"page"},{"location":"getting_started/#Initialization-of-M_0","page":"Getting Started","title":"Initialization of M_0","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The initialization of M_0 for non-Hermitian and non-symmetric cases are slightly difference, which is caused by their different ways to set the given spectrum.","category":"page"},{"location":"getting_started/#Non-Hermitian-matrix-2","page":"Getting Started","title":"Non-Hermitian matrix","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For non-Hermitian matrix, the diagonal of M_0 are set to be eigenvalues given by users. The strict upper triangular part is empty, and the strict lower triangular part can be customized by the users. An example of M_0 is given as below, which takes the example of spectrum we gave in previous subsection. In this example, the entries marked as times can be either 0 or any other numbers specified by the users.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"M_0=beginbmatrix\n1              \ntimes  2+i            \ntimes  times  3-3i        \ntimes  times  times  4        \ntimes  times  times  times  5+i      \ntimes  times  times  times  times  6-21i  \ntimes  times  times  times  times  times  7  \ntimes  times  times  times  times  times  times  8\nendbmatrix","category":"page"},{"location":"getting_started/#Non-Symmetric-matrix-2","page":"Getting Started","title":"Non-Symmetric matrix","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For the non-symmetric case, three diagonals of offsets (-1 0 1) are reserved for the given spectrum, thus, users can only customize M_0 from its diagonal of offset -2. Here is an example, which uses also the spectrum introduced in previous section.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"M_0=beginbmatrix\n1              \n  textcolorgreen2  textcolorgreen1          \ntimes  textcolorgreen-1  textcolorgreen2         \ntimes  times    textcolorred3  textcolorred2      \ntimes  times  times  textcolorred-2  textcolorred3      \ntimes  times  times  times    -5   \ntimes  times  times  times  times    textcolorblue4   textcolorblue9\ntimes  times  times  times  times  times  textcolorblue-9  textcolorblue4\nendbmatrix","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Cleary, for each conjugate pair of eigenvalues a+bi and a-bi, three diagonals of M_0 are filled by a small block of matrix","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"beginvmatrix\na  b \n-b  a\nendvmatrix","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"whose eigenvalues are exactly a-bi and a+bi.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nFor the initialization of M_0, SMG2S.jl will take care of setting the given spectrum. The user only needs to customize the others entries of its lower triangular part.","category":"page"},{"location":"getting_started/#Generation-of-Nilpotent-Matrix","page":"Getting Started","title":"Generation of Nilpotent Matrix","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"A simple nilpotent matrix A can be a sparse matrix whose only one upper diagonal of indexing diag are non-zeros, which is filled with continuous 1 and 0. The maximum of continuous 1 can be fixed as a user-specific value nbOne, this will leads to A^i=0 in limited number of steps. Here are an example of nilpotent matrix with diag=1 and nbOne=3:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"M_0=beginbmatrix\n     0                  \n       1                \n         1              \n           1            \n             0          \n               1        \n                 1      \n                  0     \n                    1  \n                      1\n                      \n                        \nendbmatrix","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nInitialization of M_0 and generation of different nilpotent matrices will result in sparse matrices with different sparsity patterns (see Gallery: Sparsity Patterns),\nTherefore SMG2S.jl leaves as much as possible room to the users for the customization.\nMeanwhile, we provides also some default routines for them, which are free to be used by the users without concerning always about customizing everything by themselves.","category":"page"},{"location":"licence/#Licence","page":"Licence","title":"Licence","text":"","category":"section"},{"location":"licence/","page":"Licence","title":"Licence","text":"SMG2S.jl is licensed under the MIT License. For more details click here.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multiple examples are provided in the Github repository of SMG2S.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Click here for more details.","category":"page"},{"location":"gallery/#Gallery:-Some-Sparsity-Patterns","page":"Gallery: Sparsity Patterns","title":"Gallery: Some Sparsity Patterns","text":"","category":"section"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"The different sparisty patterns shown in this section are generated by Example: patterns.jl. The parameters for each case are also listed together with the plots.","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -7800, diag_u: -7790, nbOne: 10, nilpdiag: 1000, sp: 0.0008","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 1)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -7800, diag_u: -7790, nbOne: 10, nilpdiag: 100, sp: 0.05","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 2)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -800, diag_u: -790, nbOne: 10, nilpdiag: 100, sp: 0.05","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 3)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -800, diag_u: -790, nbOne: 10, nilpdiag: 10, sp: 0.05","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 4)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -7800, diag_u: -6000, nbOne: 10, nilpdiag: 7000, sp: 0.0008","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 5)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -7800, diag_u: -7790, nbOne: 10, nilpdiag: 1000, sp: 0.8","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 6)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -7800, diag_u: -7000, nbOne: 20, nilpdiag: 1000, sp: 0.005","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 7)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -1800, diag_u: -10, nbOne: 1000, nilpdiag: 1000, sp: 0.0005","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 8)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -9800, diag_u: -6800, nbOne: 10, nilpdiag: 7000, sp: 0.0005","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 9)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -9800, diag_u: -6800, nbOne: 20, nilpdiag: 1500, sp: 0.004","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 10)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -9800, diag_u: -6800, nbOne: 70, nilpdiag: 1500, sp: 0.004","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 11)","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"size: 10000, diag_l: -9900, diag_u: -800, nbOne: 70, nilpdiag: 3500, sp: 0.0008","category":"page"},{"location":"gallery/","page":"Gallery: Sparsity Patterns","title":"Gallery: Sparsity Patterns","text":"(Image: Pattern 12)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SMG2S.jl is a Julia implementation of the Scalable Matrix Generation with Given Spectrum (SMG2S). SMG2S was initially implemented based MPI (Message Passing Interface) and C++, which is able to generate very large-scale non-Hermitian/Symmetric Sparse matrices in parallel on modern supercomputers. For more details about this parallel implementation of SMG2S, click here.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea of creating a sparse matrix generator came from the fact that the spectrum of matrix have large impacts on the convergence behaviour of iterative linear solvers, such as the Krylov subspace method. Generating very large sparse with given spectrum would be beneficial both for the study/research on the numerical methods and benchmarking of the parallel performance of existing iterative solvers on supercomputers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main consideration of the MPI/C++ implementation was its parallel efficiency on supercomputers, thus a lot constraints were artificially posed, which leave very few space to be customized by the users. This results in a very limited types of sparsity patterns of generated matrices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, the sparsity patterns are in fact really important for the evaluation the performance of algorithms of sparse matrices, especially their parallel efficiency. Different sparsity patterns can results in very different parallel performance which requires specific implementation and optimization.     ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore, different with the MPI/C++ version, SMG2S.jl is introduced which is try to give as much as possible room to the users to generate the matrices with a diverse types of sparsity patterns.","category":"page"},{"location":"","page":"Home","title":"Home","text":"👉  [Gallery of some generated sparsity patterns]","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Support of generating of both Non-Hermitian and Non-Symmetric sparse matrix\nThe generated matrices are naturally Sparse with non-trivial sparsity pattern\nGiven Spectrum: the spectrum of generated matrix is the same as the one specified by the users\nSparsity Patterns is Controllable (in some sense)\nit is able to very efficiently generate high dimension matrices","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, SMG2S.jl is only able to be installed from its github repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The command to install SMG2S.jl within Julia REPL (terminal) is","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg;Pkg.add(PackageSpec(url=\"https://github.com/SMG2S/SMG2S.jl\", rev=\"main\"))","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SMG2S\n\n#Define size of matrix to be generated\nsize = 100\n\n#maximum number of continous `1` in the diagonal of generated nilpotent matrix\nnbOne = 4\n#offsets of lower diagonals between which the matrix will be initially filled\ndiag_l = -20\ndiag_u = -5\n\n#a function to generate the user-provided spectrum, `idx` is the indexing of eigenvalues\nfunction f(idx::Integer, size = size)\n    return 10 * cos(((idx-1) / 2) * 2 * π / size) + 5\nend\n\n#create a empty vector to store the generated eigenvalues\n#Attention that this vector should always in complex scalar type\nspec = zeros(ComplexF64, size)\n\n#Setting up the spectrum with function `f`\nSpectrum!(spec, f, size)\n\n#Generating a non-symmetric sparse matrix and store it into `genMat`\ngenMat = nonsym(nbOne, size, diag_l, diag_u, spec)","category":"page"},{"location":"#Credits","page":"Home","title":"Credits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following people are involved in the development of SMG2S:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Xinzhe Wu (main development and algorithms)\nSerge G. Petiton (maths and algorithms)\nHervé Gachlier (maths)\n...","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this project is useful for your work please consider","category":"page"},{"location":"","page":"Home","title":"Home","text":"Citing the relevant paper\nLeaving a star on the GitHub repository","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We always would like to re-factor the MPI/C++ version following the scheme in SMG2S.jl. However, we lack of man power, because the current contributors can only work on that during very limited part time. If you have intention to take part in this project, feel free to contact us.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Any questions? Just send an email to us.","category":"page"},{"location":"citing/#Citing-SMG2S","page":"Citing SMG2S","title":"Citing SMG2S","text":"","category":"section"},{"location":"citing/","page":"Citing SMG2S","title":"Citing SMG2S","text":"If you find SMG2S useful in your project, we kindly request that you cite the following paper:","category":"page"},{"location":"citing/","page":"Citing SMG2S","title":"Citing SMG2S","text":"@article{wu2020parallel,\n  title={A parallel generator of non-Hermitian matrices computed from given spectra},\n  author={Wu, Xinzhe and Petiton, Serge G and Lu, Yutong},\n  journal={Concurrency and Computation: Practice and Experience},\n  volume={32},\n  number={20},\n  pages={e5710},\n  year={2020},\n  publisher={Wiley Online Library},\n  doi={https://doi.org/10.1002/cpe.5710}\n}","category":"page"},{"location":"citing/","page":"Citing SMG2S","title":"Citing SMG2S","text":"A preprint can be downloaded here.","category":"page"},{"location":"citing/","page":"Citing SMG2S","title":"Citing SMG2S","text":"The very initial idea of SMG2S is coming from here.","category":"page"}]
}
